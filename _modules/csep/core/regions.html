

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>csep.core.regions &mdash; pyCSEP v0.7.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=05c9169f"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <!-- Google Analytics -->
    <!-- added options to anonymize ip and disable cookies using {'storage': 'none'} 
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-495056-15', 'auto', {'storage': 'none'});
    ga('set', 'anonymizeIp', true);
    ga('send', 'pageview');
    </script> -->

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            pyCSEP
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/installing.html">Installing pyCSEP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/core_concepts.html">Core Concepts for Beginners</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/theory.html">Theory of CSEP Tests</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials and Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/catalog_filtering.html">Catalogs operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/plot_gridded_forecast.html">Plotting gridded forecast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/gridded_forecast_evaluation.html">Grid-based Forecast Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/quadtree_gridded_forecast_evaluation.html">Quadtree Grid-based Forecast Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/working_with_catalog_forecasts.html">Working with catalog-based forecasts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/catalog_forecast_evaluation.html">Catalog-based Forecast Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/plot_customizations.html">Plot customizations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/catalogs.html">Catalogs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/forecasts.html">Forecasts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/evaluations.html">Evaluations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/regions.html">Regions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Help &amp; Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/glossary.html">Terms and Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/publications.html">Referenced Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/roadmap.html">Development Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/developer_notes.html">Developer Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/api_reference.html">API Reference</a></li>
</ul>


    
        <p class="caption">
            <span class="caption-text">Source code and contributing</span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="https://github.com/SCECCode/pycsep/issues">Getting help</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECcode/pycsep/blob/master/CHANGELOG.md">Change log</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECcode/pycsep/blob/master/CONTRIBUTING.md">Contributing</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECcode/pycsep/blob/master/CODE_OF_CONDUCT.md">Code of Conduct</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECcode/pycsep/blob/master/LICENSE">License</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECCode/pycsep">Source Code</a></li>
            
        </ul>
    

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pyCSEP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../csep.html">csep</a></li>
      <li class="breadcrumb-item active">csep.core.regions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for csep.core.regions</h1><div class="highlight"><pre>
<span></span><span class="c1"># Python imports</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">compress</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">xml.etree</span><span class="w"> </span><span class="kn">import</span> <span class="n">ElementTree</span> <span class="k">as</span> <span class="n">ET</span>

<span class="c1"># Third-party imports</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">mercantile</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely</span><span class="w"> </span><span class="kn">import</span> <span class="n">geometry</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely.ops</span><span class="w"> </span><span class="kn">import</span> <span class="n">unary_union</span>

<span class="c1"># PyCSEP imports</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">csep.utils.calc</span><span class="w"> </span><span class="kn">import</span> <span class="n">bin1d_vec</span><span class="p">,</span> <span class="n">cleaner_range</span><span class="p">,</span> <span class="n">first_nonnan</span><span class="p">,</span> <span class="n">last_nonnan</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">csep.utils.scaling_relationships</span><span class="w"> </span><span class="kn">import</span> <span class="n">WellsAndCoppersmith</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">csep.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">Polygon</span>

<span class="k">def</span><span class="w"> </span><span class="nf">california_relm_collection_region</span><span class="p">(</span><span class="n">dh_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;relm-california-collection&quot;</span><span class="p">,</span> <span class="n">use_midpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return collection region for California RELM testing region</span>

<span class="sd">    Args:</span>
<span class="sd">        dh_scale (int): factor of two multiple to change the grid size</span>
<span class="sd">        mangitudes (array-like): array representing the lower bin edges of the magnitude bins</span>
<span class="sd">        name (str): human readable identifer</span>
<span class="sd">        use_midpoints (bool): if true, treat values in file as midpoints. default = true.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`csep.core.spatial.CartesianGrid2D`</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: dh_scale must be a factor of two</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dh_scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_scale must be a factor of two or dh_scale must equal unity.&quot;</span><span class="p">)</span>

    <span class="c1"># we can hard-code the dh because we hard-code the filename</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span> <span class="s1">&#39;RELMCollectionArea.dat&#39;</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_midpoint</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dh_scale</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="n">dh_scale</span>

    <span class="c1"># turn points into polygons and make region object</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">relm_region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span> <span class="n">dh</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="n">magnitudes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">relm_region</span>

<div class="viewcode-block" id="california_relm_region">
<a class="viewcode-back" href="../../../reference/generated/csep.core.regions.california_relm_region.html#csep.core.regions.california_relm_region">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">california_relm_region</span><span class="p">(</span><span class="n">dh_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;relm-california&quot;</span><span class="p">,</span> <span class="n">use_midpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns class representing California testing region.</span>

<span class="sd">    This region can</span>
<span class="sd">    be used to create gridded datasets for earthquake forecasts. The XML file appears to use the</span>
<span class="sd">    midpoint, and the .dat file uses the origin in the &quot;lower left&quot; corner.</span>

<span class="sd">    Args:</span>
<span class="sd">        dh_scale: can resample this grid by factors of 2</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`csep.core.spatial.CartesianGrid2D`</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: dh_scale must be a factor of two</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dh_scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_scale must be a factor of two or dh_scale must equal unity.&quot;</span><span class="p">)</span>

        <span class="c1"># use default file path from python package</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span> <span class="s1">&#39;csep-forecast-template-M5.xml&#39;</span><span class="p">)</span>
    <span class="n">csep_template</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="n">points</span><span class="p">,</span> <span class="n">dh</span> <span class="o">=</span> <span class="n">parse_csep_template</span><span class="p">(</span><span class="n">csep_template</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_midpoint</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dh_scale</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="n">dh_scale</span>

    <span class="c1"># turn points into polygons and make region object</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">relm_region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span> <span class="n">dh</span><span class="p">,</span><span class="n">magnitudes</span><span class="o">=</span><span class="n">magnitudes</span><span class="p">,</span>
                                  <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">relm_region</span></div>


<div class="viewcode-block" id="italy_csep_region">
<a class="viewcode-back" href="../../../reference/generated/csep.core.regions.italy_csep_region.html#csep.core.regions.italy_csep_region">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">italy_csep_region</span><span class="p">(</span><span class="n">dh_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;csep-italy&quot;</span><span class="p">,</span> <span class="n">use_midpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns class representing Italian testing region.</span>

<span class="sd">        This region can be used to create gridded datasets for earthquake forecasts. The region is defined by the</span>
<span class="sd">        file &#39;forecast.italy.M5.xml&#39; and contains a spatially gridded region with 0.1° x 0.1° cells.</span>

<span class="sd">        Args:</span>
<span class="sd">            dh_scale: can resample this grid by factors of 2</span>
<span class="sd">            magnitudes (array-like): bin edges for magnitudes. if provided, will be bound to the output region class.</span>
<span class="sd">                                     this argument provides a short-cut for creating space-magnitude regions.</span>
<span class="sd">            name (str): human readable identify given to the region</span>
<span class="sd">            use_midpoint (bool): if true, treat values in file as midpoints. default = true.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`csep.core.spatial.CartesianGrid2D`</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: dh_scale must be a factor of two</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dh_scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_scale must be a factor of two or dh_scale must equal unity.&quot;</span><span class="p">)</span>

        <span class="c1"># use default file path from python package</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span> <span class="s1">&#39;forecast.italy.M5.xml&#39;</span><span class="p">)</span>
    <span class="n">csep_template</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="n">points</span><span class="p">,</span> <span class="n">dh</span> <span class="o">=</span> <span class="n">parse_csep_template</span><span class="p">(</span><span class="n">csep_template</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_midpoint</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dh_scale</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="n">dh_scale</span>

    <span class="c1"># turn points into polygons and make region object</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">italy_region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span> <span class="n">dh</span><span class="p">,</span>
                                   <span class="n">magnitudes</span><span class="o">=</span><span class="n">magnitudes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">italy_region</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">italy_csep_collection_region</span><span class="p">(</span><span class="n">dh_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;csep-italy-collection&quot;</span><span class="p">,</span> <span class="n">use_midpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return collection region for Italy CSEP collection region</span>

<span class="sd">        Args:</span>
<span class="sd">            dh_scale (int): factor of two multiple to change the grid size</span>
<span class="sd">            mangitudes (array-like): array representing the lower bin edges of the magnitude bins</span>
<span class="sd">            name (str): human readable identifer</span>
<span class="sd">            use_midpoint (bool): if true, treat values in file as midpoints. default = true.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`csep.core.spatial.CartesianGrid2D`</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: dh_scale must be a factor of two</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dh_scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_scale must be a factor of two or dh_scale must equal unity.&quot;</span><span class="p">)</span>

    <span class="c1"># we can hard-code the dh because we hard-code the filename</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span> <span class="s1">&#39;italy.collection.nodes.dat&#39;</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_midpoint</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dh_scale</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="n">dh_scale</span>

    <span class="c1"># turn points into polygons and make region object</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">relm_region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span> <span class="n">dh</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="n">magnitudes</span><span class="p">,</span>
                                  <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">relm_region</span>

<span class="k">def</span><span class="w"> </span><span class="nf">nz_csep_region</span><span class="p">(</span><span class="n">dh_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;csep-nz&quot;</span><span class="p">,</span> <span class="n">use_midpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return collection region for the New Zealand CSEP testing region</span>

<span class="sd">    Args:</span>
<span class="sd">        dh_scale (int): factor of two multiple to change the grid size</span>
<span class="sd">        mangitudes (array-like): array representing the lower bin edges of the magnitude bins</span>
<span class="sd">        name (str): human readable identifer</span>
<span class="sd">        use_midpoints (bool): if true, treat values in file as midpoints. default = true.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`csep.core.spatial.CartesianGrid2D`</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: dh_scale must be a factor of two</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dh_scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_scale must be a factor of two or dh_scale must equal unity.&quot;</span><span class="p">)</span>

    <span class="c1"># we can hard-code the dh because we hard-code the filename</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span> <span class="s1">&#39;nz.testing.nodes.dat&#39;</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_midpoint</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dh_scale</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="n">dh_scale</span>

    <span class="c1"># turn points into polygons and make region object</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">nz_region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span> <span class="n">dh</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="n">magnitudes</span><span class="p">,</span>
                                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nz_region</span>

<span class="k">def</span><span class="w"> </span><span class="nf">nz_csep_collection_region</span><span class="p">(</span><span class="n">dh_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;csep-nz-collection&quot;</span><span class="p">,</span> <span class="n">use_midpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return collection region for the New Zealand CSEP collection region</span>

<span class="sd">    Args:</span>
<span class="sd">        dh_scale (int): factor of two multiple to change the grid size</span>
<span class="sd">        mangitudes (array-like): array representing the lower bin edges of the magnitude bins</span>
<span class="sd">        name (str): human readable identifer</span>
<span class="sd">        use_midpoints (bool): if true, treat values in file as midpoints. default = true.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`csep.core.spatial.CartesianGrid2D`</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: dh_scale must be a factor of two</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dh_scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_scale must be a factor of two or dh_scale must equal unity.&quot;</span><span class="p">)</span>

    <span class="c1"># we can hard-code the dh because we hard-code the filename</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span> <span class="s1">&#39;nz.collection.nodes.dat&#39;</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_midpoint</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dh_scale</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="n">dh_scale</span>

    <span class="c1"># turn points into polygons and make region object</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">nz_collection_region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span> <span class="n">dh</span><span class="p">,</span>
                                           <span class="n">magnitudes</span><span class="o">=</span><span class="n">magnitudes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nz_collection_region</span>

<div class="viewcode-block" id="global_region">
<a class="viewcode-back" href="../../../reference/generated/csep.core.regions.global_region.html#csep.core.regions.global_region">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">global_region</span><span class="p">(</span><span class="n">dh</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Creates a global region used for evaluating gridded forecasts on the global scale.</span>


<span class="sd">    Args:</span>
<span class="sd">        dh (float): Spacing for lat and lon discretization.</span>
<span class="sd">        name (str): Name of the region</span>
<span class="sd">        magnitudes(list/array): Array containing the magnitude bins</span>

<span class="sd">    Returns:</span>
<span class="sd">        csep.utils.CartesianGrid2D: Global region</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># generate latitudes</span>

    <span class="n">lons</span> <span class="o">=</span> <span class="n">cleaner_range</span><span class="p">(</span><span class="o">-</span><span class="mf">180.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span> <span class="n">dh</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">lats</span> <span class="o">=</span> <span class="n">cleaner_range</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="n">dh</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span><span class="n">lats</span><span class="p">)</span>
    <span class="n">region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">dh</span><span class="p">)],</span> <span class="n">dh</span><span class="p">,</span>
                             <span class="n">magnitudes</span><span class="o">=</span><span class="n">magnitudes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">region</span></div>


<div class="viewcode-block" id="magnitude_bins">
<a class="viewcode-back" href="../../../reference/generated/csep.core.regions.magnitude_bins.html#csep.core.regions.magnitude_bins">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">magnitude_bins</span><span class="p">(</span><span class="n">start_magnitude</span><span class="p">,</span> <span class="n">end_magnitude</span><span class="p">,</span> <span class="n">dmw</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Returns array holding magnitude bin edges.</span>

<span class="sd">    The output from this function is monotonically increasing and equally spaced bin edges that can represent magnitude</span>
<span class="sd">    bins.</span>

<span class="sd">     Args:</span>
<span class="sd">        start_magnitude (float)</span>
<span class="sd">        end_magnitude (float)</span>
<span class="sd">        dmw (float): magnitude spacing</span>

<span class="sd">    Returns:</span>
<span class="sd">        bin_edges (numpy.ndarray)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cleaner_range</span><span class="p">(</span><span class="n">start_magnitude</span><span class="p">,</span> <span class="n">end_magnitude</span><span class="p">,</span> <span class="n">dmw</span><span class="p">)</span></div>


<div class="viewcode-block" id="create_space_magnitude_region">
<a class="viewcode-back" href="../../../reference/generated/csep.core.regions.create_space_magnitude_region.html#csep.core.regions.create_space_magnitude_region">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_space_magnitude_region</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">magnitudes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple wrapper to create space-magnitude region &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">CartesianGrid2D</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">QuadtreeGrid2D</span><span class="p">))</span>  <span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;region must be CartesianGrid2D&quot;</span><span class="p">)</span>
    <span class="c1"># bind to region class</span>
    <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;magnitudes should not be None if creating space-magnitude region.&quot;</span><span class="p">)</span>
    <span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span>
    <span class="n">region</span><span class="o">.</span><span class="n">num_mag_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">region</span></div>


<div class="viewcode-block" id="parse_csep_template">
<a class="viewcode-back" href="../../../reference/generated/csep.core.regions.parse_csep_template.html#csep.core.regions.parse_csep_template">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_csep_template</span><span class="p">(</span><span class="n">xml_filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads CSEP XML template file and returns the lat/lon values</span>
<span class="sd">    for the forecast.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of tuples where tuple is (lon, lat)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">xml_filename</span><span class="p">)</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;{http://www.scec.org/xml-ns/csep/forecast/0.1}cell&#39;</span><span class="p">):</span>
        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])))</span>

    <span class="c1"># get cell spacing</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;{http://www.scec.org/xml-ns/csep/forecast/0.1}forecastData&#39;</span><span class="p">)</span>
    <span class="n">dh_elem</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;{http://www.scec.org/xml-ns/csep/forecast/0.1}defaultCellDimension&#39;</span><span class="p">)</span>
    <span class="n">dh_lat</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dh_elem</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;latRange&#39;</span><span class="p">])</span>
    <span class="n">dh_lon</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dh_elem</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;lonRange&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">dh_lat</span><span class="p">,</span> <span class="n">dh_lon</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_lat must equal dh_lon. grid needs to be regular.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">points</span><span class="p">,</span> <span class="n">dh_lat</span></div>


<div class="viewcode-block" id="increase_grid_resolution">
<a class="viewcode-back" href="../../../reference/generated/csep.core.regions.increase_grid_resolution.html#csep.core.regions.increase_grid_resolution">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">increase_grid_resolution</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a set of origin points and returns a new set with higher grid resolution. assumes the origin point is in the</span>
<span class="sd">    lower left corner. the new dh is dh / factor. This implementation requires that the decimation factor be a multiple of 2.</span>

<span class="sd">    Args:</span>
<span class="sd">        points: list of (lon,lat) tuples</span>
<span class="sd">        dh: old grid spacing</span>
<span class="sd">        factor: amount to reduce</span>

<span class="sd">    Returns:</span>
<span class="sd">        points: list of (lon,lat) tuples with spacing dh / scale</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># short-circuit recursion</span>
    <span class="k">if</span> <span class="n">factor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">points</span>

    <span class="c1"># handle edge cases</span>
    <span class="k">assert</span> <span class="n">factor</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">factor</span> <span class="o">&gt;=</span> <span class="mi">1</span>

    <span class="c1"># first start out</span>
    <span class="n">new_points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">new_dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">compute_vertex</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">new_dh</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pnt</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">:</span>
            <span class="n">new_points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span>
    <span class="c1"># call function again with new_points, new_dh, new_factor</span>
    <span class="n">new_factor</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_points</span><span class="p">),</span> <span class="n">new_dh</span><span class="p">,</span> <span class="n">new_factor</span><span class="p">)</span></div>


<div class="viewcode-block" id="masked_region">
<a class="viewcode-back" href="../../../reference/generated/csep.core.regions.masked_region.html#csep.core.regions.masked_region">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">masked_region</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">polygon</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a new region based off the coordinates in the polygon.</span>

<span class="sd">    Args:</span>
<span class="sd">        region: CartesianGrid2D object</span>
<span class="sd">        polygon: Polygon object</span>

<span class="sd">    Returns:</span>
<span class="sd">        new_region: CartesianGrid2D object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># contains is true if spatial cell in region is inside the polygon</span>
    <span class="n">contains</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">midpoints</span><span class="p">())</span>
    <span class="c1"># compress only returns elements that are true, effectively removing elements outside of the polygons</span>
    <span class="n">new_polygons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">compress</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">polygons</span><span class="p">,</span> <span class="n">contains</span><span class="p">))</span>
    <span class="c1"># create new region with the spatial cells inside the polygon</span>
    <span class="k">return</span> <span class="n">CartesianGrid2D</span><span class="p">(</span><span class="n">new_polygons</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">dh</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_aftershock_region">
<a class="viewcode-back" href="../../../reference/generated/csep.core.regions.generate_aftershock_region.html#csep.core.regions.generate_aftershock_region">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_aftershock_region</span><span class="p">(</span><span class="n">mainshock_mw</span><span class="p">,</span> <span class="n">mainshock_lon</span><span class="p">,</span> <span class="n">mainshock_lat</span><span class="p">,</span> <span class="n">num_radii</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">california_relm_region</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Creates a spatial region around a given epicenter</span>

<span class="sd">    The method uses the Wells and Coppersmith scaling relationship to determine the average fault length and creates a</span>
<span class="sd">    circular region centered at (mainshock_lon, mainshock_lat) with radius = num_radii.</span>

<span class="sd">    Args:</span>
<span class="sd">        mainshock_mw (float): magnitude of mainshock</span>
<span class="sd">        mainshock_lon (float): epicentral longitude</span>
<span class="sd">        mainshock_lat (float): epicentral latitude</span>
<span class="sd">        num_radii (float/int): number of radii of circular region</span>
<span class="sd">        region (callable): returns :class:`csep.utils.spatial.CartesianGrid2D`</span>
<span class="sd">        **kwargs (dict): passed to region callable</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`csep.utils.spatial.CartesianGrid2D`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rupture_length</span> <span class="o">=</span> <span class="n">WellsAndCoppersmith</span><span class="o">.</span><span class="n">mag_length_strike_slip</span><span class="p">(</span><span class="n">mainshock_mw</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>
    <span class="n">aftershock_polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="o">.</span><span class="n">from_great_circle_radius</span><span class="p">((</span><span class="n">mainshock_lon</span><span class="p">,</span> <span class="n">mainshock_lat</span><span class="p">),</span>
                                                          <span class="n">num_radii</span> <span class="o">*</span> <span class="n">rupture_length</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">aftershock_region</span> <span class="o">=</span> <span class="n">masked_region</span><span class="p">(</span><span class="n">region</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">aftershock_polygon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">aftershock_region</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">grid_spacing</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Figures out the length and</span>

<span class="sd">    Args:</span>
<span class="sd">        vertices: Vertices describe a single node in grid.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dh: grid spacing</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get first two vertices</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># compute both differences, because unless point is the same one is bound to be the dh</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;grid spacing must be regular for cartesian grid.&quot;</span><span class="p">)</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">])</span>
    <span class="c1"># this would happen if the same point is repeated twice</span>
    <span class="k">if</span> <span class="n">dh</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Problem computing grid spacing cannot be zero.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dh</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_vertex</span><span class="p">(</span><span class="n">origin_point</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the bounding box of a rectangular polygon given its origin points and spacing dh.</span>

<span class="sd">    Args:</span>
<span class="sd">        origin_points: list of tuples, where tuple is (x, y)</span>
<span class="sd">        dh: spacing</span>
<span class="sd">        tol: used to eliminate overlapping polygons in the case of a rectangular mesh, defaults to</span>
<span class="sd">             the machine tolerance.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of polygon edges</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="p">((</span><span class="n">origin_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">origin_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">origin_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">origin_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dh</span> <span class="o">-</span> <span class="n">tol</span><span class="p">),</span>
            <span class="p">(</span><span class="n">origin_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dh</span> <span class="o">-</span> <span class="n">tol</span><span class="p">,</span> <span class="n">origin_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dh</span> <span class="o">-</span> <span class="n">tol</span><span class="p">),</span>
            <span class="p">(</span><span class="n">origin_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dh</span> <span class="o">-</span> <span class="n">tol</span><span class="p">,</span> <span class="n">origin_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">bbox</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_vertices</span><span class="p">(</span><span class="n">origin_points</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function to compute vertices for multiple points. Default tolerance is set to machine precision</span>
<span class="sd">    of floating point number.</span>

<span class="sd">    Args:</span>
<span class="sd">        origin_points: 2d ndarray</span>

<span class="sd">    Notes:</span>
<span class="sd">        (x,y) should be accessible like:</span>
<span class="sd">        #&gt;&gt;&gt; x_coords = origin_points[:,0]</span>
<span class="sd">        #&gt;&gt;&gt; y_coords = origin_points[:,1]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">compute_vertex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">),</span> <span class="n">origin_points</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_bin_catalog_spatio_magnitude_counts</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">mags</span><span class="p">,</span> <span class="n">n_poly</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">idx_map</span><span class="p">,</span> <span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">,</span> <span class="n">mag_bins</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of event counts as ndarray with shape (n_poly, n_cat) where each value</span>
<span class="sd">    represents the event counts within the polygon.</span>

<span class="sd">    Using [:, :, 1] index of the mask, we store the mapping between the index of n_poly and</span>
<span class="sd">    that polygon in the mask. Additionally, the polygons are ordered such that the index of n_poly</span>
<span class="sd">    in the result corresponds to the index of the polygons.</span>

<span class="sd">    Eventually, we can make a structure that could contain both of these, but the trade-offs will need</span>
<span class="sd">    to be compared against performance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># index in cartesian grid for events in data. note, this has a different index than the</span>
    <span class="c1"># vector of polygons. this mapping is stored in [:,:,1] index of mask</span>
    <span class="c1"># index in 2d grid</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">binx</span><span class="p">)</span>
    <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">biny</span><span class="p">)</span>
    <span class="n">mag_idxs</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="n">mag_bins</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">right_continuous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># start with zero event counts in each bin</span>
    <span class="n">event_counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_poly</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_bins</span><span class="p">)))</span>
    <span class="c1"># does not seem that we can vectorize this part</span>
    <span class="n">skipped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="ow">and</span> <span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">mag_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># getting spatial bin from mask</span>
            <span class="n">hash_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx_map</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">mag_idx</span> <span class="o">=</span> <span class="n">mag_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># update event counts in that polygon</span>
            <span class="n">event_counts</span><span class="p">[(</span><span class="n">hash_idx</span><span class="p">,</span> <span class="n">mag_idx</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skipped</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lats</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mags</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">event_counts</span><span class="p">,</span> <span class="n">skipped</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_bin_catalog_spatial_counts</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">n_poly</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">idx_map</span><span class="p">,</span> <span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of event counts as ndarray with shape (n_poly) where each value</span>
<span class="sd">    represents the event counts within the polygon.</span>

<span class="sd">    Using [:, :, 1] index of the mask, we store the mapping between the index of n_poly and</span>
<span class="sd">    that polygon in the mask. Additionally, the polygons are ordered such that the index of n_poly</span>
<span class="sd">    in the result corresponds to the index of the polygons.</span>

<span class="sd">    We can make a structure that could contain both of these, but the trade-offs will need</span>
<span class="sd">    to be compared against performance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ai</span><span class="p">,</span> <span class="n">bi</span> <span class="o">=</span> <span class="n">binx</span><span class="p">,</span> <span class="n">biny</span>
    <span class="c1"># will return negative</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">ai</span><span class="p">)</span>
    <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">bi</span><span class="p">)</span>
    <span class="c1"># bin1d returns -1 if outside the region</span>
    <span class="c1"># todo: think about how to change this behavior for less confusions, bc -1 is an actual value that can be chosen</span>
    <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">idy</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idy</span><span class="p">,</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># this can be memory optimized by keeping short list and storing index, only for case where n/2 events</span>
    <span class="n">event_counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_poly</span><span class="p">)</span>
    <span class="c1"># selecting the indexes into polygons correspoding to lons and lats within the grid</span>
    <span class="n">hash_idx</span> <span class="o">=</span> <span class="n">idx_map</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">],</span><span class="n">idx</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># aggregate in counts</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">event_counts</span><span class="p">,</span> <span class="n">hash_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">event_counts</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_bin_catalog_probability</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">n_poly</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">idx_map</span><span class="p">,</span> <span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of event counts as ndarray with shape (n_poly) where each value</span>
<span class="sd">    represents the event counts within the polygon.</span>

<span class="sd">    Using [:, :, 1] index of the mask, we store the mapping between the index of n_poly and</span>
<span class="sd">    that polygon in the mask. Additionally, the polygons are ordered such that the index of n_poly</span>
<span class="sd">    in the result corresponds to the index of the polygons.</span>

<span class="sd">    We can make a structure that could contain both of these, but the trade-offs will need</span>
<span class="sd">    to be compared against performance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ai</span><span class="p">,</span> <span class="n">bi</span> <span class="o">=</span> <span class="n">binx</span><span class="p">,</span> <span class="n">biny</span>
    <span class="c1"># returns -1 if outside of the bbox</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">ai</span><span class="p">)</span>
    <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">bi</span><span class="p">)</span>
    <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">idy</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idy</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">event_counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_poly</span><span class="p">)</span>
    <span class="c1"># [:,:,1] is a mapping from the polygon array to cartesian grid</span>
    <span class="n">hash_idx</span> <span class="o">=</span> <span class="n">idx_map</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">],</span><span class="n">idx</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># dont accumulate just set to one for probability</span>
    <span class="n">event_counts</span><span class="p">[</span><span class="n">hash_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">event_counts</span>

<div class="viewcode-block" id="CartesianGrid2D">
<a class="viewcode-back" href="../../../reference/generated/csep.core.regions.CartesianGrid2D.html#csep.core.regions.CartesianGrid2D">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CartesianGrid2D</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a 2D cartesian gridded region.</span>

<span class="sd">    The class provides functions to query onto an index 2D Cartesian grid and maintains a mapping between space coordinates defined</span>
<span class="sd">    by polygons and the index into the polygon array.</span>

<span class="sd">    Custom regions can be easily created by using the from_polygon classmethod. This function will accept an arbitrary closed</span>
<span class="sd">    polygon and return a CartesianGrid class with only points inside the polygon to be valid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CartesianGrid2D.__init__">
<a class="viewcode-back" href="../../../reference/generated/csep.core.regions.CartesianGrid2D.html#csep.core.regions.CartesianGrid2D.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;cartesian2d&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span> <span class="o">=</span> <span class="n">polygons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_bitmask_vec</span><span class="p">()</span>
        <span class="c1"># in mask, True = bad value and False = good value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bbox_mask</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># contains the mapping from polygon_index to the mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># index values of polygons array into the 2d cartesian grid, based on the midpoint.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span>
        <span class="c1"># Bounds [origin, top_right]</span>
        <span class="n">orgs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origins</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">orgs</span><span class="p">,</span> <span class="n">orgs</span> <span class="o">+</span> <span class="n">dh</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Number of polygons in region &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_index_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the index of lons, lats in self.polygons</span>

<span class="sd">        Args:</span>
<span class="sd">            lons: ndarray-like</span>
<span class="sd">            lats: ndarray-like</span>

<span class="sd">        Returns:</span>
<span class="sd">            idx: ndarray-like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idy</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at least one lon and lat pair contain values that are outside of the valid region.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bbox_mask</span><span class="p">[</span><span class="n">idy</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at least one lon and lat pair contain values that are outside of the valid region.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span><span class="p">[</span><span class="n">idy</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_location_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the polygon associated with the index idx.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices: index of polygon in region</span>

<span class="sd">        Returns:</span>
<span class="sd">            Polygon</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">polys</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_masked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns bool array lons and lats are not included in the spatial region.</span>

<span class="sd">        .. note:: The ordering of lons and lats should correspond to the ordering of the lons and lats in the data.</span>

<span class="sd">        Args:</span>
<span class="sd">            lons: array-like</span>
<span class="sd">            lats: array-like</span>

<span class="sd">        Returns:</span>
<span class="sd">            idx: array-like</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="p">)</span>
        <span class="c1"># handles the case where values are outside of the region</span>
        <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">idy</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox_mask</span><span class="p">[</span><span class="n">idy</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="c1"># manually set values outside region</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns 2d ndrray representation of the data set, corresponding to the bounding box.</span>

<span class="sd">        Args:</span>
<span class="sd">            data:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bbox_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="p">)</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns rectangular bounding box around region. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">dh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">dh</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">midpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns midpoints of rectangular polygons in region &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">origins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns origins of rectangular polygons in region &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">adict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="s1">&#39;dh&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dh</span><span class="p">),</span>
            <span class="s1">&#39;polygons&#39;</span><span class="p">:</span> <span class="p">[{</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">],</span>
            <span class="s1">&#39;class_id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">adict</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">adict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Creates a region object from a dictionary &quot;&quot;&quot;</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">adict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;polygons&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">adict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dh&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">magnitudes</span> <span class="o">=</span> <span class="n">adict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;magnitudes&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">adict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;CartesianGrid2D&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">origins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;cannot create region object without origins&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;cannot create region without dh&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">origins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">adict</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="n">adict</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">adict</span> <span class="ow">in</span> <span class="n">origins</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;origins must be numpy array like.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">magnitudes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">magnitudes</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;magnitudes must be numpy array like.&#39;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_origins</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="o">=</span><span class="n">dh</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="n">magnitudes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_origins</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates instance of class from 2d numpy.array of lon/lat origins.</span>

<span class="sd">        Note: Grid spacing should be constant in the entire region. This condition is not explicitly checked for for performance</span>
<span class="sd">        reasons.</span>

<span class="sd">        Args:</span>
<span class="sd">            origins (numpy.ndarray like): [:,0] = lons and [:,1] = lats</span>
<span class="sd">            magnitudes (numpy.array like): optional, if provided will bind magnitude information to the class.</span>

<span class="sd">        Returns:</span>
<span class="sd">            cls</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ensure we can access the lons and lats</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">origins</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">origins</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;origins must be of type numpy.array or be numpy array like.&quot;</span><span class="p">)</span>

        <span class="c1"># dh must be regular, no explicit checking.</span>
        <span class="k">if</span> <span class="n">dh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dh2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lons</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">lons</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dh1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lats</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">lats</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">dh1</span><span class="p">,</span> <span class="n">dh2</span><span class="p">])</span>

        <span class="n">region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">(</span><span class="n">polygons</span><span class="o">=</span><span class="p">[</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)],</span>
                                 <span class="n">dh</span><span class="o">=</span><span class="n">dh</span><span class="p">,</span>
                                 <span class="n">magnitudes</span><span class="o">=</span><span class="n">magnitudes</span><span class="p">,</span>
                                 <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">region</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build_bitmask_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        same as build mask but using vectorized calls to bin1d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># build bounding box of set of polygons based on origins</span>
        <span class="n">nd_origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="p">[(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">nd_origins</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">nd_origins</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])),</span>
                <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nd_origins</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nd_origins</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))]</span>

        <span class="c1"># get midpoints for hashing</span>
        <span class="n">midpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>

        <span class="c1"># set up grid over bounding box</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">cleaner_range</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dh</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">cleaner_range</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dh</span><span class="p">)</span>

        <span class="c1"># set up mask array, 1 is index 0 is mask</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="mi">2</span><span class="p">])</span>

        <span class="c1"># set all indices to nan</span>
        <span class="n">a</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># bin1d returns the index of polygon within the cartesian grid</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">midpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">)</span>
        <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">midpoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ys</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">)):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># build mask in dim=0; here masked values are 1. see note below.</span>
            <span class="k">if</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># note: csep1 gridded forecast file format convention states that a &quot;1&quot; indicates a valid cell, which is the opposite</span>
                    <span class="c1"># of the masking criterion</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">a</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tight_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="c1"># creates tight bounding box around the region</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">points</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>

        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span>
        <span class="n">unique_poly</span> <span class="o">=</span> <span class="n">poly</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>

        <span class="c1"># merges all the cell polygons into one</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">precision</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique_poly</span><span class="p">]</span>
        <span class="n">joined_poly</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">polygons</span><span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">joined_poly</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">xy</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">bounds</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_cell_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute the area of each polygon in sq. kilometers.</span>

<span class="sd">            Returns:</span>
<span class="sd">                out (numpy.array): numpy array containing cell area in km^2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">origin</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origins</span><span class="p">()):</span>
            <span class="n">top_right</span> <span class="o">=</span> <span class="n">origin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dh</span>
            <span class="n">area</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">geographical_area_from_bounds</span><span class="p">(</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">top_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_right</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">area</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">geographical_area_from_bounds</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes area of spatial cell identified by origin coordinate and top right cooridnate.</span>
<span class="sd">    The functions computes area only for square/rectangle bounding box by based on spherical earth assumption.</span>
<span class="sd">    Args:</span>
<span class="sd">        lon1,lat1 : Origin coordinates</span>
<span class="sd">        lon2,lat2: Top right coordinates</span>
<span class="sd">    Returns:</span>
<span class="sd">        Area of cell in Km2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lon1</span> <span class="o">==</span> <span class="n">lon2</span> <span class="ow">or</span> <span class="n">lat1</span> <span class="o">==</span> <span class="n">lat2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">earth_radius_km</span> <span class="o">=</span> <span class="mf">6371.</span>
        <span class="n">R2</span> <span class="o">=</span> <span class="n">earth_radius_km</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">rad_per_deg</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0e0</span>

        <span class="n">strip_area_steradian</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0e0</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mf">90.0e0</span> <span class="o">-</span> <span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rad_per_deg</span><span class="p">))</span> \
                           <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0e0</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mf">90.0e0</span> <span class="o">-</span> <span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">rad_per_deg</span><span class="p">))</span>
        <span class="n">area_km2</span> <span class="o">=</span> <span class="n">strip_area_steradian</span> <span class="o">*</span> <span class="n">R2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">360.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">area_km2</span>

<span class="k">def</span><span class="w"> </span><span class="nf">quadtree_grid_bounds</span><span class="p">(</span><span class="n">quadk</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the bottom-left and top-right coordinates corresponding to every quadkey</span>

<span class="sd">    Args:</span>
<span class="sd">        qk : Array of Strings</span>
<span class="sd">        Quadkeys.</span>

<span class="sd">    Returns:</span>
<span class="sd">        grid_coords : Array of floats</span>
<span class="sd">                    [lon1,lat1,lon2,lat2]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">origin_lat</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">origin_lon</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">top_right_lon</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">top_right_lat</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">quadk</span><span class="p">)):</span>
        <span class="n">origin_lon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mercantile</span><span class="o">.</span><span class="n">bounds</span><span class="p">(</span><span class="n">mercantile</span><span class="o">.</span><span class="n">quadkey_to_tile</span><span class="p">(</span><span class="n">quadk</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">west</span><span class="p">)</span>
        <span class="n">origin_lat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mercantile</span><span class="o">.</span><span class="n">bounds</span><span class="p">(</span><span class="n">mercantile</span><span class="o">.</span><span class="n">quadkey_to_tile</span><span class="p">(</span><span class="n">quadk</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">south</span><span class="p">)</span>

        <span class="n">top_right_lon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mercantile</span><span class="o">.</span><span class="n">bounds</span><span class="p">(</span><span class="n">mercantile</span><span class="o">.</span><span class="n">quadkey_to_tile</span><span class="p">(</span><span class="n">quadk</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">east</span><span class="p">)</span>
        <span class="n">top_right_lat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mercantile</span><span class="o">.</span><span class="n">bounds</span><span class="p">(</span><span class="n">mercantile</span><span class="o">.</span><span class="n">quadkey_to_tile</span><span class="p">(</span><span class="n">quadk</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">north</span><span class="p">)</span>

    <span class="n">grid_origin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">origin_lon</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">origin_lat</span><span class="p">)))</span>
    <span class="n">grid_top_right</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">top_right_lon</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">top_right_lat</span><span class="p">)))</span>
    <span class="n">grid_bounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">grid_origin</span><span class="p">,</span> <span class="n">grid_top_right</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">grid_bounds</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_vertex_bounds</span><span class="p">(</span><span class="n">bound_point</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function to compute vertices using bounding points for multiple points. Default tolerance is set to machine precision</span>
<span class="sd">    of floating point number.</span>

<span class="sd">    Args:</span>
<span class="sd">        bounding points: nx4 ndarray</span>
<span class="sd">                        [lon_origin, lat_origin, lon_top_right, lat_origin]</span>
<span class="sd">    Notes:</span>
<span class="sd">        (x,y) should be accessible like:</span>
<span class="sd">        #&gt;&gt;&gt; origin coords = origin_points[:,0:1]</span>
<span class="sd">        #&gt;&gt;&gt; Top right coords = origin_points[:,2:3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="p">((</span><span class="n">bound_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bound_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">bound_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bound_point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">tol</span><span class="p">),</span>
            <span class="p">(</span><span class="n">bound_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">tol</span><span class="p">,</span> <span class="n">bound_point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">tol</span><span class="p">),</span>
            <span class="p">(</span><span class="n">bound_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">tol</span><span class="p">,</span> <span class="n">bound_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">bbox</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_vertices_bounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function to compute vertices using bounding points for multiple points. Default tolerance is set to machine precision</span>
<span class="sd">    of floating point number.</span>

<span class="sd">    Args:</span>
<span class="sd">        bounding points: nx4 ndarray</span>
<span class="sd">                        [lon_origin, lat_origin, lon_top_right, lat_origin]</span>
<span class="sd">    Notes:</span>
<span class="sd">        (x,y) should be accessible like:</span>
<span class="sd">        #&gt;&gt;&gt; origin coords = origin_points[:,0:1]</span>
<span class="sd">        #&gt;&gt;&gt; Top right coords = origin_points[:,2:3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">compute_vertex_bounds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">),</span> <span class="n">bounds</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_create_tile</span><span class="p">(</span><span class="n">quadk</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">qk</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Alert: This Function uses GLOBAL variable (qk) and (num).</span>

<span class="sd">        Provides multi-resolution quadtree spatial grid based on seismic density. It takes in a starting quadtree Tile (Quadkey),</span>
<span class="sd">        then keeps on increasing the zoom-level of every Tile (or dividing cell) recursively, unless every cell meets the cell dividion criteria.</span>

<span class="sd">        The primary criterion of dividing a parent cell into 4 child cells is a threshold on seismic denisity.</span>
<span class="sd">        The cells are divided unless evevry cell cas number of earthquakes less than &quot;threshold&quot;.</span>
<span class="sd">        The cell division of any also stops if it reaches maximum zoom-level (zoom)</span>

<span class="sd">        Args:</span>
<span class="sd">            quadk : String</span>
<span class="sd">                    0, 1, 2, 3 or any desired starting level of Quad key.</span>
<span class="sd">            threshold : int</span>
<span class="sd">                    Max number of earthquakes/cell allowed</span>
<span class="sd">            zoom: int</span>
<span class="sd">                    Maximum zoom level allowed for a quadkey</span>
<span class="sd">            lon : float</span>
<span class="sd">                    longitudes of earthquakes in catalog</span>
<span class="sd">            lat : float</span>
<span class="sd">                    latitude of earthquakes in catalog</span>

<span class="sd">        Returns:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">mercantile</span><span class="o">.</span><span class="n">bounds</span><span class="p">(</span><span class="n">mercantile</span><span class="o">.</span><span class="n">quadkey_to_tile</span><span class="p">(</span><span class="n">quadk</span><span class="p">))</span>
    <span class="n">eqs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">lon</span> <span class="o">&gt;=</span> <span class="n">boundary</span><span class="o">.</span><span class="n">west</span><span class="p">,</span> <span class="n">lat</span> <span class="o">&gt;=</span> <span class="n">boundary</span><span class="o">.</span><span class="n">south</span><span class="p">),</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">lon</span> <span class="o">&lt;</span> <span class="n">boundary</span><span class="o">.</span><span class="n">east</span><span class="p">,</span> <span class="n">lat</span> <span class="o">&lt;</span> <span class="n">boundary</span><span class="o">.</span><span class="n">north</span><span class="p">))</span>
    <span class="n">num_eqs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="n">eqs</span><span class="p">])</span>
    <span class="c1">#    global qk</span>
    <span class="c1">#    global num</span>

    <span class="c1"># Setting the Min Threshold of Area 1 sq. km. Instead of Depth</span>

    <span class="k">if</span> <span class="n">num_eqs</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">quadk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">zoom</span><span class="p">:</span>  <span class="c1"># #qk_area_km(quadk)&gt;4:</span>
        <span class="c1"># print(&#39;inside If, Current Quad key &#39;, quadk)</span>
        <span class="c1"># print(&#39;Length of Quadkey &#39;, len(quadk))</span>
        <span class="c1"># # print(&#39;Num of Eqs &#39;, num_eqs)</span>

        <span class="n">_create_tile</span><span class="p">(</span><span class="n">quadk</span> <span class="o">+</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">qk</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="n">_create_tile</span><span class="p">(</span><span class="n">quadk</span> <span class="o">+</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">qk</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="n">_create_tile</span><span class="p">(</span><span class="n">quadk</span> <span class="o">+</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">qk</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="n">_create_tile</span><span class="p">(</span><span class="n">quadk</span> <span class="o">+</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">qk</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># print(&#39;inside ELSE, Current Quad key &#39;, quadk)</span>
        <span class="c1"># print(&#39;Num of Eqs &#39;, num_eqs)</span>
        <span class="c1">#           qk = numpy.append(qk, quadk)</span>
        <span class="n">qk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quadk</span><span class="p">)</span>
        <span class="c1">#            num = numpy.append(num, num_eqs)</span>
        <span class="n">num</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_eqs</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_create_tile_fix_len</span><span class="p">(</span><span class="n">quadk</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">qk</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ***Alert: This Function uses GLOBAL variable (qk).</span>

<span class="sd">        Provides single-resolution quadtree grid. It takes in a starting quadkey (or Quadrant of Globe),</span>
<span class="sd">        then keeps on keeps on dividing it into 4 children unless the maximum zoom-level is achieved</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quadk : String</span>
<span class="sd">            0, 1, 2, 3 or any desired starting level of Quad key.</span>
<span class="sd">            zoom : TYPE</span>
<span class="sd">            Length of Quad Key OR Depth of grid.</span>


<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">quadk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">zoom</span><span class="p">:</span>
        <span class="c1">#        print(&#39;inside If, Current Quad key &#39;, quadk)</span>
        <span class="c1">#        print(&#39;Len of QK: &#39;, len(quadk))</span>

        <span class="n">_create_tile_fix_len</span><span class="p">(</span><span class="n">quadk</span> <span class="o">+</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">qk</span><span class="p">)</span>

        <span class="n">_create_tile_fix_len</span><span class="p">(</span><span class="n">quadk</span> <span class="o">+</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">qk</span><span class="p">)</span>

        <span class="n">_create_tile_fix_len</span><span class="p">(</span><span class="n">quadk</span> <span class="o">+</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">qk</span><span class="p">)</span>

        <span class="n">_create_tile_fix_len</span><span class="p">(</span><span class="n">quadk</span> <span class="o">+</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">qk</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># print(&#39;inside ELSE, Current Quad key &#39;, quadk)</span>
        <span class="c1"># print(&#39;Num of Eqs &#39;, num_eqs)</span>
        <span class="c1">#        qk = numpy.append(qk, quadk)</span>
        <span class="n">qk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quadk</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">QuadtreeGrid2D</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Respresents a 2D quadtree gridded region. The class provides functionality to generate multi-resolution or single-resolution quadtree grid.</span>
<span class="sd">    It also enables users to load already available quadtree grird. It also provides functions to query onto an index 2D grid ad maintains mapping</span>
<span class="sd">    between space coordinates and defined polygons and the index into the polygon array.</span>

<span class="sd">    Note: It is replica of CartesianGrid2D class but with quadtree approach, with implementation of all the relevant functions required to CSEP1 tests</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">quadkeys</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;QuadtreeGrid2d&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            polygons: Represents the object of class &quot;polygons&quot; defined through a collection of vertices.</span>
<span class="sd">                        This polygon is 2d and vertices are obtained as corner points of quadtree tile.</span>
<span class="sd">            quadkeys: Unique identifier of each quadtree tile. Quadkeys of every tile defines a grid cell.</span>
<span class="sd">                        This is the first thing computed while acquiring quadtree grid. Rest can be computed from this.</span>
<span class="sd">            bounds: number of cells x [lon1, lat1, lon2, lat2], corresponding to origin coordinates and top right coordinates fo each grid cell</span>
<span class="sd">            name: Name of grid</span>
<span class="sd">            mask: Masked cells. NotImplemented yet. Always keep it none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span> <span class="o">=</span> <span class="n">polygons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quadkeys</span> <span class="o">=</span> <span class="n">quadkeys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_area</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1"># a, xs, ys = self._get_idx_map_xs_ys()</span>
        <span class="c1"># self.xs = xs</span>
        <span class="c1"># self.ys = ys</span>
        <span class="c1"># self.idx_map = a</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Number of polygons in region &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_cell_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls function geographical_area_from_bounds and computes area of each grid cell. It also modified class variable &quot;self.cell_area&quot;</span>
<span class="sd">        It iterates over all the cells of grid and passes bounding coordinates of every cell to function  geographical_area_from_bounds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_area</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">geographical_area_from_bounds</span><span class="p">(</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">bb</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">bb</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_area</span> <span class="o">=</span> <span class="n">cell_area</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_area</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_index_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the index of lons, lats in self.polygons</span>

<span class="sd">        Args:</span>
<span class="sd">            lons: ndarray-like</span>
<span class="sd">            lats: ndarray-like</span>

<span class="sd">        Returns:</span>
<span class="sd">            idx: ndarray-like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If its array or many coords</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_location</span><span class="p">(</span><span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lats</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">idx</span>
        <span class="c1"># It its just one Lon/Lon</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_location</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">idx</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Takes in single Lon and Lat and finds its Polygon Index.</span>

<span class="sd">        Returns:</span>
<span class="sd">            index number of polyons</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">lon</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">lat</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span>
                                    <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">lon</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">lat</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_location_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the polygon associated with the index idx.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx: index of polygon in region</span>

<span class="sd">        Returns:</span>
<span class="sd">            Polygon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">polys</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_spatial_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">,</span> <span class="n">mag_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Gets the number of earthquakes in each cell for available catalog.</span>
<span class="sd">        Uses QuadtreeGrid2D.get_index_of function to map every earthquake location to its corresponding cell</span>

<span class="sd">        Args:</span>
<span class="sd">            catalog: CSEP Catalog</span>
<span class="sd">            mag_bins: Magnitude discritization used in earthquake forecast mdoel</span>
<span class="sd">                      Note: mag_bins are only required to filter catalog for minimum magnitude</span>

<span class="sd">        Return:</span>
<span class="sd">            spatial counts: Number of earthquakes in each cell</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mag_bins</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mag_bins</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">mag_bins</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">magnitudes</span>

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">catalog</span><span class="o">.</span><span class="n">get_magnitudes</span><span class="p">())</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">mag_bins</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-----Warning-----&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Catalog contains magnitudes below the min magnitude range&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Filtering catalog with Magnitude: &quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">mag_bins</span><span class="p">))</span>
            <span class="n">catalog</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s1">&#39;magnitude &gt;= &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">mag_bins</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">catalog</span><span class="o">.</span><span class="n">get_latitudes</span><span class="p">())</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bbox</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">catalog</span><span class="o">.</span><span class="n">get_latitudes</span><span class="p">())</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bbox</span><span class="p">()[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----Warning---&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Catalog exceeds grid bounds, so catalog filtering&quot;</span><span class="p">)</span>
            <span class="n">catalog</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s1">&#39;latitude &lt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bbox</span><span class="p">()[</span><span class="mi">3</span><span class="p">]))</span>
            <span class="n">catalog</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s1">&#39;latitude &gt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bbox</span><span class="p">()[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="n">lon</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">get_longitudes</span><span class="p">()</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">get_latitudes</span><span class="p">()</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quadkeys</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_of</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_spatial_magnitude_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">,</span> <span class="n">mag_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the number of earthquakes in for each spatio-magnitude bin for available catalog</span>
<span class="sd">        Uses QuadtreeGrid2D.get_index_of function to map every earthquake location to its corresponding cell</span>
<span class="sd">        Uses bin1d_vec function to map earthquake magnitude to its respecrtive bin.</span>

<span class="sd">        Args:</span>
<span class="sd">            catalog: CSEPCatalog</span>
<span class="sd">            mag_bins: Magnitude discritization used in earthquake forecast model</span>

<span class="sd">        Return:</span>
<span class="sd">            Spatial-magnitude counts</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mag_bins</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mag_bins</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">mag_bins</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">magnitudes</span>

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">catalog</span><span class="o">.</span><span class="n">get_magnitudes</span><span class="p">())</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">mag_bins</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-----Warning-----&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Catalog contains magnitudes below the min magnitude range&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Filtering catalog with Magnitude: &quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">mag_bins</span><span class="p">))</span>
            <span class="n">catalog</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s1">&#39;magnitude &gt;= &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">mag_bins</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">catalog</span><span class="o">.</span><span class="n">get_latitudes</span><span class="p">())</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bbox</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">catalog</span><span class="o">.</span><span class="n">get_latitudes</span><span class="p">())</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bbox</span><span class="p">()[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----Warning---&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Catalog exceeds grid bounds filtering events outside of the region boundary&quot;</span><span class="p">)</span>
            <span class="n">catalog</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s1">&#39;latitude &lt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bbox</span><span class="p">()[</span><span class="mi">3</span><span class="p">]))</span>
            <span class="n">catalog</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s1">&#39;latitude &gt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bbox</span><span class="p">()[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="n">lon</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">get_longitudes</span><span class="p">()</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">get_latitudes</span><span class="p">()</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">get_magnitudes</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quadkeys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_bins</span><span class="p">)])</span>

        <span class="n">idx_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_of</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="n">idx_mag</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">mag_bins</span><span class="p">,</span> <span class="n">right_continuous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">(</span><span class="n">idx_loc</span><span class="p">,</span> <span class="n">idx_mag</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns rectangular bounding box around region. &quot;&quot;&quot;</span>
        <span class="c1">#        return (self.xs.min(), self.xs.max(), self.ys.min(), self.ys.max())</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">midpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns midpoints of rectangular polygons in region &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">origins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns origins of rectangular polygons in region &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">adict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="s1">&#39;polygons&#39;</span><span class="p">:</span> <span class="p">[{</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">adict</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">save_quadtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Saves the quadtree grid (quadkeys) in a text file</span>

<span class="sd">            Args:</span>
<span class="sd">                filename (str): filename to store file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadkeys</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_catalog</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">catalog</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates instance of class from 2d numpy.array of lon/lat of Catalog.</span>
<span class="sd">        Provides multi-resolution quadtree spatial grid based on seismic density. It starts from whole globe as 4 cells (Quadkeys:&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;),</span>
<span class="sd">        then keeps on increasing the zoom-level of every Tile recursively, unless every cell meets the division criteria.</span>

<span class="sd">        The primary criterion of dividing a parent cell into 4 child cells is a threshold on seismic density.</span>
<span class="sd">        The cells are divided unless every cell has number of earthquakes less than &quot;threshold&quot;.</span>
<span class="sd">        The division of a cell also stops if it reaches maximum zoom-level (zoom)</span>

<span class="sd">        Args:</span>
<span class="sd">            catalog (CSEPCatalog): catalog used to create quadtree</span>
<span class="sd">            threshold (int): Max earthquakes allowed per cells</span>
<span class="sd">            zoom (int): Max zoom allowed for a cell</span>
<span class="sd">            magnitudes (array-like): left end values of magnitude discretization</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of QuadtreeGrid2D</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lon</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">get_longitudes</span><span class="p">()</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">get_latitudes</span><span class="p">()</span>

        <span class="n">qk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">_create_tile</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">qk</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
        <span class="n">_create_tile</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">qk</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
        <span class="n">_create_tile</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">qk</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
        <span class="n">_create_tile</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">qk</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="n">qk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">quadtree_grid_bounds</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span>
        <span class="n">region</span> <span class="o">=</span> <span class="n">QuadtreeGrid2D</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">compute_vertices_bounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">)],</span>
            <span class="n">qk</span><span class="p">,</span>
            <span class="n">bounds</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span>

        <span class="k">return</span> <span class="n">region</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_single_resolution</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Creates instance of class at single-resolution using provided zoom-level.</span>
<span class="sd">        Provides single-resolution quadtree grid. It starts from whole globe as 4 cells (Quadkeys:&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;),</span>
<span class="sd">        then keeps on keeps on dividing every cell into 4 children unless the maximum zoom-level is achieved</span>

<span class="sd">        Args:</span>
<span class="sd">            zoom: Max zoom allowed for a cell</span>
<span class="sd">            magnitude: magnitude discretization</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of QuadtreeGrid2D</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">qk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_create_tile_fix_len</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">qk</span><span class="p">)</span>
        <span class="n">_create_tile_fix_len</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">qk</span><span class="p">)</span>
        <span class="n">_create_tile_fix_len</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">qk</span><span class="p">)</span>
        <span class="n">_create_tile_fix_len</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">qk</span><span class="p">)</span>

        <span class="n">qk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span>

        <span class="n">bounds</span> <span class="o">=</span> <span class="n">quadtree_grid_bounds</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span>

        <span class="n">region</span> <span class="o">=</span> <span class="n">QuadtreeGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">compute_vertices_bounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">)],</span> <span class="n">qk</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span>
                                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span>
        <span class="k">return</span> <span class="n">region</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_quadkeys</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">quadk</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Creates instance of class from available quadtree grid.</span>

<span class="sd">        Args:</span>
<span class="sd">            quadk (list): List of quad keys strings corresponding to an already available quadtree grid</span>
<span class="sd">            magnitudes (array-like): left end-points of magnitude discretization</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of QuadtreeGrid2D</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">quadtree_grid_bounds</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quadk</span><span class="p">))</span>

        <span class="n">region</span> <span class="o">=</span> <span class="n">QuadtreeGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">compute_vertices_bounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">)],</span> <span class="n">quadk</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span>
                                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span>

        <span class="k">return</span> <span class="n">region</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_idx_map_xs_ys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inside _get_idx_map&#39;</span><span class="p">)</span>
        <span class="n">nd_origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nd_origins</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nd_origins</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
        <span class="c1">#Get the index map</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_of</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns 2d ndrray representation of the data set, corresponding to the bounding box.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (numpy.array): array of values corresponding to cells in the quadtree region</span>

<span class="sd">        Returns:</span>
<span class="sd">            results (numpy.array): 2d numpy array with rates on cartesian grid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_idx_map_xs_ys</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="p">)</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
                <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tight_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># creates tight bounding box around the region, probably a faster way to do this.</span>
        <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">asc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">argmin</span> <span class="o">=</span> <span class="n">first_nonnan</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="n">argmax</span> <span class="o">=</span> <span class="n">last_nonnan</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="c1"># points are stored clockwise</span>
            <span class="n">poly_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">argmin</span><span class="p">])]</span><span class="o">.</span><span class="n">points</span>
            <span class="n">asc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">poly_min</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">asc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">poly_min</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">poly_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">argmax</span><span class="p">])]</span><span class="o">.</span><span class="n">points</span>
            <span class="n">lat_0</span> <span class="o">=</span> <span class="n">poly_max</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lat_1</span> <span class="o">=</span> <span class="n">poly_max</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># last two points are &#39;right hand side of polygon&#39;</span>
            <span class="k">if</span> <span class="n">lat_0</span> <span class="o">&lt;</span> <span class="n">lat_1</span><span class="p">:</span>
                <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_max</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_max</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_max</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_max</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># close the loop</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">asc</span> <span class="o">+</span> <span class="n">desc</span><span class="p">)</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span>
        <span class="n">unique_poly</span> <span class="o">=</span> <span class="n">poly</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
        <span class="n">unique_poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unique_poly</span><span class="p">,</span> <span class="p">[</span><span class="n">unique_poly</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unique_poly</span>


<span class="k">def</span><span class="w"> </span><span class="nf">california_quadtree_region</span><span class="p">(</span><span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;california-quadtree&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns object of QuadtreeGrid2D representing quadtree grid for California RELM testing region.</span>
<span class="sd">    The grid is already generated at zoom-level = 12 and it is loaded through classmethod: QuadtreeGrid2D.from_quadkeys</span>
<span class="sd">    The grid cells at zoom level 12 are selected using the external boundary of RELM california region.</span>
<span class="sd">    This grid can be used to create gridded datasets for earthquake forecasts.</span>


<span class="sd">    Args:</span>
<span class="sd">        magnitudes: Magnitude discretization</span>
<span class="sd">        name: string</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`csep.core.spatial.QuadtreeGrid2D</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># use default file path from python package</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span> <span class="s1">&#39;california_qk_zoom=12.txt&#39;</span><span class="p">)</span>
    <span class="n">qk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;str&#39;</span><span class="p">)</span>
    <span class="n">california_region</span> <span class="o">=</span> <span class="n">QuadtreeGrid2D</span><span class="o">.</span><span class="n">from_quadkeys</span><span class="p">(</span><span class="n">qk</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="n">magnitudes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">california_region</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
 
&#169; 2020, University of Southern California.
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>