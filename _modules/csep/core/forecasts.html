

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>csep.core.forecasts &mdash; pyCSEP v0.7.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=05c9169f"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <!-- Google Analytics -->
    <!-- added options to anonymize ip and disable cookies using {'storage': 'none'} 
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-495056-15', 'auto', {'storage': 'none'});
    ga('set', 'anonymizeIp', true);
    ga('send', 'pageview');
    </script> -->

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            pyCSEP
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/installing.html">Installing pyCSEP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/core_concepts.html">Core Concepts for Beginners</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/theory.html">Theory of CSEP Tests</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials and Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/catalog_filtering.html">Catalogs operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/plot_gridded_forecast.html">Plotting gridded forecast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/gridded_forecast_evaluation.html">Grid-based Forecast Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/quadtree_gridded_forecast_evaluation.html">Quadtree Grid-based Forecast Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/working_with_catalog_forecasts.html">Working with catalog-based forecasts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/catalog_forecast_evaluation.html">Catalog-based Forecast Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/plot_customizations.html">Plot customizations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/catalogs.html">Catalogs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/forecasts.html">Forecasts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/evaluations.html">Evaluations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/regions.html">Regions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Help &amp; Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/glossary.html">Terms and Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/publications.html">Referenced Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/roadmap.html">Development Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/developer_notes.html">Developer Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/api_reference.html">API Reference</a></li>
</ul>


    
        <p class="caption">
            <span class="caption-text">Source code and contributing</span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="https://github.com/SCECCode/pycsep/issues">Getting help</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECcode/pycsep/blob/master/CHANGELOG.md">Change log</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECcode/pycsep/blob/master/CONTRIBUTING.md">Contributing</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECcode/pycsep/blob/master/CODE_OF_CONDUCT.md">Code of Conduct</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECcode/pycsep/blob/master/LICENSE">License</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECCode/pycsep">Source Code</a></li>
            
        </ul>
    

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pyCSEP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../csep.html">csep</a></li>
      <li class="breadcrumb-item active">csep.core.forecasts</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for csep.core.forecasts</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>

<span class="c1"># third-party imports</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">csep.utils.log</span><span class="w"> </span><span class="kn">import</span> <span class="n">LoggingMixin</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">csep.core.regions</span><span class="w"> </span><span class="kn">import</span> <span class="n">CartesianGrid2D</span><span class="p">,</span> <span class="n">create_space_magnitude_region</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">csep.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">Polygon</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">csep.utils.calc</span><span class="w"> </span><span class="kn">import</span> <span class="n">bin1d_vec</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">csep.utils.time_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">decimal_year</span><span class="p">,</span> <span class="n">datetime_to_utc_epoch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">csep.core.catalogs</span><span class="w"> </span><span class="kn">import</span> <span class="n">AbstractBaseCatalog</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">csep.utils.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">SECONDS_PER_ASTRONOMICAL_YEAR</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">csep.utils.plots</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_spatial_dataset</span>


<span class="c1"># idea: should this be a SpatialDataSet and the class below SpaceMagnitudeDataSet, bc of functions like</span>
<span class="c1">#       get_latitudes(), and get_longitudes()</span>
<span class="c1">#       or this class should be refactored as to use the underlying region</span>

<span class="c1"># idea: this needs to handle non-carteisan regions, so maybe (lons, lats) should be a single variable like locations</span>

<span class="c1"># note: these are specified to 2D data sets and some minor refactoring needs to happen here.</span>

<span class="c1"># todo: add mask to dataset that has the shape of data. consider using numpy.ma module to hold these values</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GriddedDataSet</span><span class="p">(</span><span class="n">LoggingMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents space-magnitude discretized seismicity implementation.</span>

<span class="sd">    Map-based and discrete forecasts, such as those provided by time-independent forecasts can be stored using this format.</span>
<span class="sd">    This object will provide some convenience routines and functionality around the numpy.ndarray primative that</span>
<span class="sd">    actually stores the space-time magnitude forecast.</span>

<span class="sd">    Earthquake forecasts based on discrete space-magnitude regions are read into this format by default. This format can</span>
<span class="sd">    support multiple types of region including 2d and 3d cartesian meshes. The appropriate region must be provided. By default</span>
<span class="sd">    the magniutde is always treated as the &#39;fast&#39; dimension of the numpy.array.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        data (numpy.ndarray): 2d numpy.ndarray containing the spatial and magnitude bins with magnitudes being the fast dimension.</span>
<span class="sd">        region: csep.utils.spatial.2DCartesianGrid class containing the mapping of the data points into the region.</span>
<span class="sd">        mags: list or numpy.ndarray class containing the lower (inclusive) magnitude values from the discretized</span>
<span class="sd">              magnitudes. The magnitude bins should be regularly spaced.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Constructs GriddedSeismicity class.</span>

<span class="sd">        Attributes:</span>
<span class="sd">            data (numpy.ndarray): numpy.ndarray</span>
<span class="sd">            region:</span>
<span class="sd">            name:</span>
<span class="sd">            time_horizon:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># note: do not access this member through _data, always use .data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">region</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># this value lets us scale the forecast without much additional memory constraints and makes the calls</span>
        <span class="c1"># idempotent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Contains the spatio-magnitude forecast as 2d numpy.ndarray.</span>

<span class="sd">        The dimensions of this array are (num_spatial_bins, num_magnitude_bins). The spatial bins can be indexed through</span>
<span class="sd">        a look up table as part of the region class. The magnitude bins used are stored as directly as an attribute of</span>
<span class="sd">        class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">event_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns a sum of the forecast data &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Sums over all of the forecast data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">spatial_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the counts (or rates) of earthquakes within each spatial bin.</span>

<span class="sd">        Args:</span>
<span class="sd">            cartesian (bool): if true, will return a 2d grid representing the bounding box of the forecast</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray containing the count in each bin</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cartesian</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">get_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_latitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the latitude of the lower left node of the spatial grid&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">origins</span><span class="p">()[:,</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_longitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the lognitude of the lower left node of the spatial grid &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">origins</span><span class="p">()[:,</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_valid_midpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the midpoints of the valid testing region</span>

<span class="sd">            Returns:</span>
<span class="sd">                lons (numpy.array), lats (numpy.array): two numpy arrays containing the valid midpoints from the forecast</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">latitudes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">longitudes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">bbox_max</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">latitudes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">midpoints</span><span class="p">()[</span><span class="n">idx</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">longitudes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">midpoints</span><span class="p">()[</span><span class="n">idx</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">longitudes</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">latitudes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">polygons</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_index_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the index of lons, lats in spatial region</span>

<span class="sd">        See csep.utils.spatial.CartesianGrid2D for more details.</span>

<span class="sd">        Args:</span>
<span class="sd">            lons: ndarray-like</span>
<span class="sd">            lats: ndarray-like</span>

<span class="sd">        Returns:</span>
<span class="sd">            idx: ndarray-like</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if lons or lats are outside of the region.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">get_index_of</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scales forecast by floating point value.</span>

<span class="sd">        Args:</span>
<span class="sd">            val: int, float, or ndarray. This value multiplicatively scale the values in forecast. Use a value of</span>
<span class="sd">                 1 to recover original value of the forecast.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: must be int, float, or ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">adict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MarkedGriddedDataSet</span><span class="p">(</span><span class="n">GriddedDataSet</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a gridded forecast in CSEP. The data must be stored as a 2D numpy array where the fast column is magnitude.</span>
<span class="sd">    The shape of this array will have (n_space_bins, n_mag_bins) and can be large.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">create_space_magnitude_region</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">magnitudes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">magnitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">min_magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the lowest magnitude bin edge &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">magnitudes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_mag_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">magnitudes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_magnitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the left edge of the magnitude bins. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitudes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">num_nodes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">spatial_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integrates over magnitudes to return the spatial version of the forecast.</span>

<span class="sd">        Args:</span>
<span class="sd">            cartesian (bool): if true, will return a 2d grid representing the bounding box of the forecast</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray containing the count in each bin</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cartesian</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">get_cartesian</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">magnitude_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns counts of events in magnitude bins &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_magnitude_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mags</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the indices into the magnitude bins of selected magnitudes</span>

<span class="sd">        Note: the right-most bin is treated as extending to infinity.</span>

<span class="sd">        Args:</span>
<span class="sd">            mags (array-like): magnitudes bin edges.</span>
<span class="sd">            tol (float): overwrite numerical tolerance, by default determined automatically from the</span>
<span class="sd">                         magnitudes&#39; dtype to account for the limited precision of floating-point values.</span>
<span class="sd">                         Only necessary to specify if the magnitudes were subject to some</span>
<span class="sd">                         floating-point operations after loading or generating them</span>
<span class="sd">                         (increased roundoff error, see :func:`csep.utils.calc.bin1d_vec`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: indices corresponding to the magnitude bins</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idm</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitudes</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">right_continuous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idm</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mags outside the range of forecast magnitudes.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idm</span>


<div class="viewcode-block" id="GriddedForecast">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.GriddedForecast.html#csep.core.forecasts.GriddedForecast">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GriddedForecast</span><span class="p">(</span><span class="n">MarkedGriddedDataSet</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Class to represent grid-based forecasts &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GriddedForecast.__init__">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.GriddedForecast.html#csep.core.forecasts.GriddedForecast.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for GriddedForecast class</span>

<span class="sd">        Args:</span>
<span class="sd">            start_time (datetime.datetime):</span>
<span class="sd">            end_time (datetime.datetime):</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">start_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">end_time</span></div>


<div class="viewcode-block" id="GriddedForecast.scale_to_test_date">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.GriddedForecast.scale_to_test_date.html#csep.core.forecasts.GriddedForecast.scale_to_test_date">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">scale_to_test_date</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_datetime</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Scales forecast data by the fraction of the date.</span>

<span class="sd">        Uses the concept of decimal years to keep track of leap years. See the csep.utils.time_utils.decimal_year for</span>
<span class="sd">        details on the implementation. If datetime is before the start_date or after the end_date, we will scale the</span>
<span class="sd">        forecast by unity.</span>

<span class="sd">        These datetime objects can be timezone aware in UTC timezone or both not time aware. This function will raise a</span>
<span class="sd">        TypeError according to the specifications of datetime module if these conditions are not met.</span>

<span class="sd">        Args:</span>
<span class="sd">            test_datetime (datetime.datetime): date to scale the forecast</span>
<span class="sd">            in_place (bool): if false, creates a deep copy of the object and scales that instead</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Note: this will throw a TypeError if datetimes are not either both time aware or not time aware.</span>
        <span class="k">if</span> <span class="n">test_datetime</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">test_datetime</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">fore_dur</span> <span class="o">=</span> <span class="n">decimal_year</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span> <span class="o">-</span> <span class="n">decimal_year</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>

        <span class="c1"># we are adding one day, bc tests are considered to occur at the end of the day specified by test_datetime.</span>
        <span class="n">test_date_dec</span> <span class="o">=</span> <span class="n">decimal_year</span><span class="p">(</span><span class="n">test_datetime</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">fore_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">test_date_dec</span> <span class="o">-</span> <span class="n">decimal_year</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">))</span> <span class="o">/</span> <span class="n">fore_dur</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">fore_frac</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="GriddedForecast.target_event_rates">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.GriddedForecast.target_event_rates.html#csep.core.forecasts.GriddedForecast.target_event_rates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">target_event_rates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_catalog</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generates data set of target event rates given a target data.</span>

<span class="sd">        The data should already be scaled to the same length as the forecast time horizon. Explicit checks for these</span>
<span class="sd">        cases are not conducted in this function.</span>

<span class="sd">        If scale=True then the target event rates will be scaled down to the rates for one day. This choice of time</span>
<span class="sd">        can be made without a loss of generality. Please see Rhoades, D. A., D. Schorlemmer, M. C. Gerstenberger,</span>
<span class="sd">        A. Christophersen, J. D. Zechar, and M. Imoto (2011). Efficient testing of earthquake forecasting models,</span>
<span class="sd">        Acta Geophys 59 728-747.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_catalog (csep.core.data.AbstractBaseCatalog): data containing target events</span>
<span class="sd">            scale (bool): if true, rates will be scaled to one day.</span>

<span class="sd">        Returns:</span>
<span class="sd">            out (tuple): target_event_rates, n_fore. target event rates are the</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_catalog</span><span class="p">,</span> <span class="n">AbstractBaseCatalog</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;target_catalog must be csep.core.data.AbstractBaseCatalog class.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
            <span class="c1"># first get copy so we dont contaminate the rates of the forecast, this can be quite large for global files</span>
            <span class="c1"># if we run into memory problems, we can implement a sparse form of the forecast.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># straight-forward implementation, relies on correct start and end time</span>
            <span class="n">elapsed_days</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span><span class="o">.</span><span class="n">days</span>
            <span class="c1"># scale the data down to days</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">/</span> <span class="n">elapsed_days</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just pull reference to stored data</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># get longitudes and latitudes of target events</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">target_catalog</span><span class="o">.</span><span class="n">get_longitudes</span><span class="p">()</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">target_catalog</span><span class="o">.</span><span class="n">get_latitudes</span><span class="p">()</span>
        <span class="n">mags</span> <span class="o">=</span> <span class="n">target_catalog</span><span class="o">.</span><span class="n">get_magnitudes</span><span class="p">()</span>

        <span class="c1"># this array does not keep track of any location anymore. however, it can be computed using the data again.</span>
        <span class="n">rates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rates</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">mags</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># we return the sum of data, bc data might be scaled within this function</span>
        <span class="k">return</span> <span class="n">rates</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="GriddedForecast.get_rates">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.GriddedForecast.get_rates.html#csep.core.forecasts.GriddedForecast.get_rates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_rates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">mags</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ret_inds</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the rate associated with a longitude, latitude, and magnitude.</span>

<span class="sd">        Args:</span>
<span class="sd">            lon: longitude of interest</span>
<span class="sd">            lat: latitude of interest</span>
<span class="sd">            mag: magnitude of interest</span>
<span class="sd">            data: optional, if not none then use this data value provided with the forecast</span>

<span class="sd">        Returns:</span>
<span class="sd">            rates (float or ndarray)</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: lons lats and mags must be the same length</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mags</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;lons, lats, and mags must have the same length.&quot;</span><span class="p">)</span>
        <span class="c1"># get index of lon and lat value, if lats, lons, not in region raise value error</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_of</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>
        <span class="c1"># get index of magnitude bins, if lats, lons, not in region raise value error</span>
        <span class="n">idm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_magnitude_index</span><span class="p">(</span><span class="n">mags</span><span class="p">)</span>
        <span class="c1"># retrieve rates from internal data structure</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">idm</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rates</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">idm</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ret_inds</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rates</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rates</span></div>


<div class="viewcode-block" id="GriddedForecast.from_custom">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.GriddedForecast.from_custom.html#csep.core.forecasts.GriddedForecast.from_custom">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_custom</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">func_args</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Creates MarkedGriddedDataSet class from custom parsing function.</span>

<span class="sd">        Args:</span>
<span class="sd">            func (callable): function will be called as func(func_args).</span>
<span class="sd">            func_args (tuple): arguments to pass to func</span>
<span class="sd">            **kwargs: keyword arguments to pass to the GriddedForecast class constructor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`csep.core.forecasts.GriddedForecast`: forecast object</span>

<span class="sd">        Note:</span>
<span class="sd">            The loader function `func` needs to return a tuple that contains (data, region, magnitudes). data is a</span>
<span class="sd">            :class:`numpy.ndarray`, region is a :class:`CartesianGrid2D&lt;csep.core.regions.CartesianGrid2D&gt;`, and</span>
<span class="sd">            magnitudes are a :class:`numpy.ndarray` consisting of the magnitude bin edges. See the function</span>
<span class="sd">            :meth:`load_ascii&lt;csep.core.forecasts.GriddedForecast.load_ascii&gt;` for an example.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">magnitudes</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">func_args</span><span class="p">)</span>
        <span class="c1"># try to ensure that data are region are compatible with one another, but we can only rely on heuristics</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="n">magnitudes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="GriddedForecast.load_ascii">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.GriddedForecast.load_ascii.html#csep.core.forecasts.GriddedForecast.load_ascii">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_ascii</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ascii_fname</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">swap_latlon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reads Forecast file from CSEP1 ascii format.</span>

<span class="sd">        The ascii format from CSEP1 testing centers. The ASCII format does not contain headers. The format is listed here:</span>

<span class="sd">        Lon_0, Lon_1, Lat_0, Lat_1, z_0, z_1, Mag_0, Mag_1, Rate, Flag</span>

<span class="sd">        For the purposes of defining region objects and magnitude bins use the Lat_0 and Lon_0 values along with Mag_0.</span>
<span class="sd">        We can assume that the magnitude bins are regularly spaced to allow us to compute Deltas.</span>

<span class="sd">        The file is row-ordered so that magnitude bins are fastest then followed by space.</span>

<span class="sd">        Args:</span>
<span class="sd">            ascii_fname: file name of csep forecast in .dat format</span>
<span class="sd">            swap_latlon (bool): if true, read forecast spatial cells as lat_0, lat_1, lon_0, lon_1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">ascii_fname</span><span class="p">)</span>
        <span class="c1"># this is very ugly, but since unique returns a sorted list, we want to get the index, sort that and then return</span>
        <span class="c1"># from the original array. same for magnitudes below.</span>
        <span class="n">all_polys</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">all_poly_mask</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_polys</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span>
        <span class="n">unique_poly</span> <span class="o">=</span> <span class="n">all_polys</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
        <span class="c1"># gives the flag for a spatial cell in the order it was presented in the file</span>
        <span class="n">poly_mask</span> <span class="o">=</span> <span class="n">all_poly_mask</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
        <span class="c1"># create magnitudes bins using Mag_0, ignoring Mag_1 bc they are regular until last bin. we dont want binary search for this</span>
        <span class="n">all_mws</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_mws</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span>
        <span class="n">mws</span> <span class="o">=</span> <span class="n">all_mws</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
        <span class="c1"># csep1 stores the lat lons as min values and not (x,y) tuples</span>
        <span class="k">if</span> <span class="n">swap_latlon</span><span class="p">:</span>
            <span class="n">bboxes</span> <span class="o">=</span> <span class="p">[((</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique_poly</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bboxes</span> <span class="o">=</span> <span class="p">[((</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique_poly</span><span class="p">]</span>
        <span class="c1"># the spatial cells are arranged fast in latitude, so this only works for the specific csep1 file format</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">unique_poly</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">unique_poly</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="c1"># create CarteisanGrid of points</span>
        <span class="n">region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span> <span class="n">dh</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">poly_mask</span><span class="p">)</span>
        <span class="c1"># get dims of 2d np.array</span>
        <span class="n">n_mag_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mws</span><span class="p">)</span>
        <span class="n">n_poly</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">num_nodes</span>
        <span class="c1"># reshape rates into correct 2d format</span>
        <span class="n">rates</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_poly</span><span class="p">,</span> <span class="n">n_mag_bins</span><span class="p">)</span>
        <span class="c1"># create / return class</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">ascii_fname</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
        <span class="n">gds</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="n">mws</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">rates</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gds</span></div>


<div class="viewcode-block" id="GriddedForecast.plot">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.GriddedForecast.plot.html#csep.core.forecasts.GriddedForecast.plot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">set_global</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_args</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Plot gridded forecast according to plate-carree projection</span>

<span class="sd">        Args:</span>
<span class="sd">            show (bool): if true, show the figure. this call is blocking.</span>
<span class="sd">            plot_args (optional/dict): dictionary containing plotting arguments for making figures</span>

<span class="sd">        Returns:</span>
<span class="sd">            axes: matplotlib.Axes.axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># no mutable function arguments</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="s1">&#39;forecast period&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">decimal_year</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">decimal_year</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1"> years&#39;</span>

        <span class="n">plot_args</span> <span class="o">=</span> <span class="n">plot_args</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="n">plot_args</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;figsize&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="n">plot_args</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># this call requires internet connection and basemap</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">plot_args</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;clabel&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;log10 M</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_magnitude</span><span class="si">}</span><span class="s1">+ rate per cell per </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">numpy</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_spatial_dataset</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_counts</span><span class="p">(</span><span class="n">cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                                          <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">set_global</span><span class="o">=</span><span class="n">set_global</span><span class="p">,</span> <span class="n">plot_args</span><span class="o">=</span><span class="n">plot_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plot_args</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;clabel&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;M</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_magnitude</span><span class="si">}</span><span class="s1">+ rate per cell per </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_spatial_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_counts</span><span class="p">(</span><span class="n">cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
                                      <span class="n">set_global</span><span class="o">=</span><span class="n">set_global</span><span class="p">,</span> <span class="n">plot_args</span><span class="o">=</span><span class="n">plot_args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div>
</div>



<div class="viewcode-block" id="CatalogForecast">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.CatalogForecast.html#csep.core.forecasts.CatalogForecast">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CatalogForecast</span><span class="p">(</span><span class="n">LoggingMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Catalog based forecast defined as a family of stochastic event sets. &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CatalogForecast.__init__">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.CatalogForecast.html#csep.core.forecasts.CatalogForecast.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">catalogs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filter_spatial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">apply_mct</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">expected_rates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_cat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">event</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">catalog_type</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span>
                 <span class="n">catalog_format</span><span class="o">=</span><span class="s1">&#39;native&#39;</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_filters</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>


<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The region information can be provided along side the data, if they are stored in one of the supported file formats.</span>
<span class="sd">        It is assumed that the region for each data is identical. If the regions are not provided with the data files,</span>
<span class="sd">        they must be provided explicitly. The california testing region can be loaded using :func:`csep.utils.spatial.california_relm_region`.</span>

<span class="sd">        There are a few different ways this class can be constructed, each</span>

<span class="sd">        The region is not required to load a forecast or to perform basic operations on a forecast, such as counting events.</span>
<span class="sd">        Any binning of events in space or magnitude will require a spatial region or magnitude bin definitions, respectively.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): Path to the file or directory containing the forecast.</span>
<span class="sd">            catalogs: iterable of :class:`csep.core.catalogs.AbstractBaseCatalog`</span>
<span class="sd">            filter_spatial (bool): if true, will filter to area defined in space region</span>
<span class="sd">            apply_mct (bool): this should be provided if a time-dependent magnitude completeness model should be</span>
<span class="sd">                              applied to the forecast</span>
<span class="sd">            filters (iterable): list of data filter strings. these override the filter_magnitude and filter_time arguments</span>
<span class="sd">            region: :class:`csep.core.spatial.CartesianGrid2D` including magnitude bins</span>
<span class="sd">            start_time (datetime.datetime): start time of the forecast</span>
<span class="sd">            end_time (datetime.datetime): end time of the forecast</span>
<span class="sd">            name (str): name of the forecast, will be used for defaults in plotting and other places</span>
<span class="sd">            n_cat (int): number of catalogs in the forecast</span>
<span class="sd">            event (:class:`csep.models.Event`): if the forecast is associated with a particular event</span>
<span class="sd">            store (bool): if true, will store catalogs on object in memory. this should only be made false if working</span>
<span class="sd">                          with very large forecast files that cannot be stored in memory</span>
<span class="sd">            apply_filters (bool): if true, filters will be applied automatically to the catalogs as the forecast</span>
<span class="sd">                                  is iterated through</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># used for labeling plots, filenames, etc, should be human readable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># path to forecast location</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="c1"># should be iterable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalogs</span> <span class="o">=</span> <span class="n">catalogs</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_catalogs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># should be a generator function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loader</span> <span class="o">=</span> <span class="n">loader</span>

        <span class="c1"># used if the forecast is associated with a particular event</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">event</span>

        <span class="c1"># if false, no filters will be applied when iterating though forecast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span> <span class="o">=</span> <span class="n">apply_filters</span>

        <span class="c1"># these can be used to filter catalogs to a desired experiment region</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span> <span class="o">=</span> <span class="n">filters</span> <span class="ow">or</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filter_spatial</span> <span class="o">=</span> <span class="n">filter_spatial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_mct</span> <span class="o">=</span> <span class="n">apply_mct</span>

        <span class="c1"># data format used for loading catalogs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog_type</span> <span class="o">=</span> <span class="n">catalog_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog_format</span> <span class="o">=</span> <span class="n">catalog_format</span>

        <span class="c1"># should be a MarkedGriddedDataSet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expected_rates</span> <span class="o">=</span> <span class="n">expected_rates</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_event_counts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># defines the space, time, and magnitude region of the forecasts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">region</span>

        <span class="c1"># start and end time of the forecast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">start_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">end_time</span>

        <span class="c1"># stores catalogs in memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">store</span>

        <span class="c1"># time horizon in years</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_horizon_years</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_epoch</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_epoch</span><span class="p">)</span> <span class="o">/</span> <span class="n">SECONDS_PER_ASTRONOMICAL_YEAR</span> <span class="o">/</span> <span class="mi">1000</span>

        <span class="c1"># number of simulated catalogs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_cat</span> <span class="o">=</span> <span class="n">n_cat</span>

        <span class="c1"># used to handle the iteration over catalogs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># load catalogs if catalogs aren&#39;t provided, this might be a generator</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalogs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_catalogs</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Allows the class to be used in a for-loop. Handles the case where the catalogs are stored as a list or</span>
<span class="sd">        loaded in using a generator function. The latter solves the problem where memory is a concern or all of the</span>
<span class="sd">        catalogs should not be held in memory at once. &quot;&quot;&quot;</span>
        <span class="n">is_generator</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_items</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalogs</span><span class="p">)</span>
            <span class="n">is_generator</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cat</span> <span class="o">==</span> <span class="n">n_items</span>
            <span class="c1"># here, we have reached the end of the list, simply reset the index to the front</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cat</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
            <span class="n">catalog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalogs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># handle generator case. a generator does not have the __len__ attribute, but an iterable does.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">catalog</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalogs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="c1"># gets a new generator function after the old one is exhausted</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">catalogs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog_format</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
                                                <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">catalogs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_catalogs</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_catalogs</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">n_cat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>

        <span class="c1"># apply filtering to catalogs, these can throw errors if not configured properly</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_filters</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">:</span>
                <span class="n">catalog</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mct</span><span class="p">:</span>
                <span class="n">catalog</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">apply_mct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">datetime_to_utc_epoch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_spatial</span><span class="p">:</span>
                <span class="n">catalog</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">filter_spatial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_event_counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">catalog</span><span class="o">.</span><span class="n">event_count</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_generator</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_catalogs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">catalog</span><span class="p">)</span>

        <span class="c1"># return potentially filtered data</span>
        <span class="k">return</span> <span class="n">catalog</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_catalogs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalogs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loader</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog_format</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">start_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">datetime_to_utc_epoch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">end_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">datetime_to_utc_epoch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">magnitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns left bin-edges of magnitude bins &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">min_magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns smallest magnitude bin edge of forecast &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span><span class="p">)</span>

<div class="viewcode-block" id="CatalogForecast.spatial_counts">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.CatalogForecast.spatial_counts.html#csep.core.forecasts.CatalogForecast.spatial_counts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spatial_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the expected spatial counts from forecast &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_rates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_expected_rates</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_rates</span><span class="o">.</span><span class="n">spatial_counts</span><span class="p">(</span><span class="n">cartesian</span><span class="o">=</span><span class="n">cartesian</span><span class="p">)</span></div>


<div class="viewcode-block" id="CatalogForecast.magnitude_counts">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.CatalogForecast.magnitude_counts.html#csep.core.forecasts.CatalogForecast.magnitude_counts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">magnitude_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns expected magnitude counts from forecast &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_rates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_expected_rates</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_rates</span><span class="o">.</span><span class="n">magnitude_counts</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_event_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns a numpy array containing the number of event counts for each catalog.</span>

<span class="sd">            Note: This function can take a while to compute if called without already iterating through a forecast that</span>
<span class="sd">            is being stored on disk. This should only happen to large forecasts that have been initialized with</span>
<span class="sd">            store = False. This should only happen on the first iteration of the catalog.</span>

<span class="sd">            Returns:</span>
<span class="sd">                (numpy.array): event counts with size equal of catalogs in forecast</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_event_counts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># event counts is filled while iterating over the catalog</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">tens_exp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">tens_exp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processed </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1"> catalogs in </span><span class="si">{</span><span class="n">t1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_event_counts</span><span class="p">)</span>

<div class="viewcode-block" id="CatalogForecast.get_expected_rates">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.CatalogForecast.get_expected_rates.html#csep.core.forecasts.CatalogForecast.get_expected_rates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_expected_rates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Compute the expected rates in space-magnitude bins</span>

<span class="sd">        Args:</span>
<span class="sd">            catalogs_iterable (iterable): collection of catalogs, should be filtered outside the function</span>
<span class="sd">            data (csep.core.AbstractBaseCatalog): observation data</span>

<span class="sd">        Return:</span>
<span class="sd">            :class:`csep.core.forecasts.GriddedForecast`</span>
<span class="sd">            list of tuple(lon, lat, magnitude) events that were skipped in binning. if data was filtered in space</span>
<span class="sd">            and magnitude beforehand this list shoudl be empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># self.n_cat might be none here, if catalogs haven&#39;t been loaded and its not yet specified.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Forecast must have space-magnitude regions to compute expected rates.&quot;</span><span class="p">)</span>
        <span class="c1"># need to compute expected rates, else return.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_rates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># compute spatial density from each data, force data region to use the forecast region</span>
                <span class="n">cat</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span>
                <span class="n">gridded_counts</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">spatial_magnitude_counts</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gridded_counts</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gridded_counts</span><span class="p">)</span>
                <span class="c1"># output status</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">tens_exp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">tens_exp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processed </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1"> catalogs in </span><span class="si">{</span><span class="n">t1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># after we iterate through the catalogs, we know self.n_cat</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cat</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expected_rates</span> <span class="o">=</span> <span class="n">GriddedForecast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                                                  <span class="n">magnitudes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">magnitudes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_rates</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot_args</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">plot_args</span> <span class="o">=</span> <span class="n">plot_args</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_rates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_expected_rates</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">args_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                     <span class="s1">&#39;grid_labels&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="s1">&#39;grid&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="s1">&#39;borders&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="s1">&#39;feature_lw&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
                     <span class="s1">&#39;basemap&#39;</span><span class="p">:</span> <span class="s1">&#39;ESRI_terrain&#39;</span><span class="p">,</span>
                     <span class="p">}</span>
        <span class="n">args_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">plot_args</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_rates</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">plot_args</span><span class="o">=</span><span class="n">args_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

<div class="viewcode-block" id="CatalogForecast.get_dataframe">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.CatalogForecast.get_dataframe.html#csep.core.forecasts.CatalogForecast.get_dataframe">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a single dataframe with all of the events from all of the catalogs.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;get_dataframe is not implemented.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="CatalogForecast.write_ascii">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.CatalogForecast.write_ascii.html#csep.core.forecasts.CatalogForecast.write_ascii">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_ascii</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">loader</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Writes data forecast to ASCII format</span>


<span class="sd">        Args:</span>
<span class="sd">            fname (str): Output filename of forecast</span>
<span class="sd">            header (bool): If true, write header information; else, do not write header.</span>


<span class="sd">        Returns:</span>
<span class="sd">            NoneType</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;write_ascii is not implemented!&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="CatalogForecast.load_ascii">
<a class="viewcode-back" href="../../../reference/generated/csep.core.forecasts.CatalogForecast.load_ascii.html#csep.core.forecasts.CatalogForecast.load_ascii">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_ascii</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Loads ASCII format for data forecast.</span>

<span class="sd">        Args:</span>
<span class="sd">            fname (str): path to file or directory containing forecast files</span>

<span class="sd">        Returns:</span>
<span class="sd">              :class:`csep.core.forecasts.CatalogForecast`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;load_ascii is not implemented!&quot;</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
 
&#169; 2020, University of Southern California.
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>